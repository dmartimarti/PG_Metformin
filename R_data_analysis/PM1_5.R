## Metformin PM1 to 5 analysis

# load libraries
library(tidyverse)
library(readxl)
library(ComplexHeatmap)
library(circlize)
library(ggrepel)
# library(PFun)
library(forcats)
library(FactoMineR) # for PCA
library(factoextra) # for PCA
library(gtools)
library(broom)
library(here)
library(openxlsx)
library(colorspace)
library(ggtext)

# options(width = 170)


# Load data ####

info = read_csv('original_data/PM1to5/Biolog_metabolites.csv',quote = "\"")

# load bacterial data

data.b = read_csv('original_data/PM1to5/Output/Summary.csv', quote = "\"") %>%
  rename(AUC_raw = `750nm_f_AUC`) %>% #`750nm_f_logAUC` data column is what we need for logAUC values
  mutate(Strain = as.character(Strain),
         ReplicateB = paste0('B', as.character(Replicate)), #Generate replicate ID which indicate that it's data for bacteria
         Type = ifelse(Type == 'Control','C','T'),
         Sample = paste(Strain, Type, sep = '_'),
         Type = factor(Type,
                       levels = c('C', 'T'),
                       labels = c('Control', 'Treatment')),
         Row = str_match_all(Well,'[:digit:]{1,}'), #Get plate row names from well name. 
         Col = str_match_all(Well,'[:alpha:]{1,}'), #Get plate column names from well name
         Row = factor(Row, levels = 1:12), #Make them categorical variable with set order them
         Col = factor(Col, levels = LETTERS[1:8]),
         SampleID = paste(Sample, Replicate, sep = '_'),
         Sample = as.factor(Sample),
         Strain = as.factor(Strain)) %>% #Change Type column coding
  group_by(Strain, Type, Plate, Replicate, Group) %>%
  mutate(AUC = AUC_raw - AUC_raw[Metabolite == 'Negative Control']) %>% # Normalisation agains negative control in each plate
  select(SampleID, Sample, Strain, Type, Replicate, ReplicateB, Index, Plate, 
         Well, Row, Col, Metabolite, MetaboliteU, EcoCycID, KEGG_ID, Group, Class, AUC_raw, AUC) %>%
  ungroup %>%
  mutate(AUC = ifelse(AUC < 0, 0, AUC))

### Summary statistics
# Note: we do not use several of these variables for the plots, but could be useful
# They were generated by Pov 

bac.byrep = data.b %>%
  unite(STR, Strain, Type, ReplicateB) %>% #Generete unique IDs by concatenating Strain, Type and Replicate values
  # Select only the columns which are necessary: descriptions, values, exclude Replicate (Now it's ReplicateB), Comment, Reader
  select(STR, Plate, Well, Row, Col, Index:Class,AUC_raw, -Replicate) %>% 
  spread(STR, AUC_raw) #Spread values into a wide table



# Replicates per plate
data.breps = data.b %>%
  group_by(Strain, Plate, Type) %>%
  summarise(Replicates = n()/96)


# Generate summary statistics for each group
bac.sum = data.b %>%
  group_by(Strain, Plate, Replicate, Group) %>%
  gather(Measure, Value, AUC_raw, AUC) %>%
  group_by(Measure, Strain, Type, Plate, Well, Index, Metabolite, MetaboliteU) %>% #Work on subsets based on selected grouping variables
  summarise(Mean = mean(Value, na.rm = TRUE), # Do selected summary over group items - replicates, ignore missing values
            SD = sd(Value, na.rm = TRUE),
            SE = SD/sqrt(n())) %>% # standard error of the mean
  ungroup %>%
  mutate(PE = Mean+SE,
         NE = Mean-SE)




bac.sum.sbs = bac.sum %>% #Remove table grouping. Can be checked via glimpse(bac.sum)
  filter(Measure == 'logAUC_raw') %>%
  select(Strain, Type, Plate, Well, Index, Mean, SD) %>%
  #Transform the table wide to long, Mean and SD become values of a column named Value, while Mean and SD coding becomes Stat column values
  gather(Stat, Value, Mean, SD) %>% 
  unite(STS, Strain, Type, Stat) %>% # Generate unique IDs for summary columns based on Strain, Type and Stat - statistic values
  spread(STS, Value) # Spread the table to wide, showing statistics in each group


bacall = bac.byrep %>% 
  left_join(bac.sum.sbs) %>% 
  select(-c(Index, Metabolite, MetaboliteU)) %>% # Join with raw replicate data
  arrange(Plate, Col, Row) %>%
  select(-c('Row', 'Col'))




# # # # # # # # #
# PCA plots ####
# # # # # # # # #

# Generate infor tables which describes samples
bioinfo = data.b %>% 
  group_by(SampleID, Sample, Strain, Type) %>%
  summarise %>%
  data.frame

# bad_mets = c('3-0-beta-D-Galactopyranosyl-D-Arabinose', 'Dihydroxy Acetone')

# filter by strain and Plate if you want
pca_b_data = data.b %>%
  filter(!Metabolite %in% c('Negative Control')) %>%
  filter(Plate %in% c('PM1', 'PM2A')) 



# some data frame transformations
pca_b_data = pca_b_data %>%
  select(SampleID, MetaboliteU, AUC) %>%
  spread(MetaboliteU, AUC) %>%
  data.frame(check.names = F)

cosa = t(pca_b_data)

rownames(pca_b_data) = pca_b_data[,1]; pca_b_data = pca_b_data[,-1]

# lets compute the PCA
res.pca = PCA(pca_b_data, scale.unit = TRUE, ncp = 5, graph = F)

# metadata 
meta_var = bioinfo 

# extract info about the individuals
ind = get_pca_ind(res.pca)
ind_df = data.frame(ind$coord[,1], ind$coord[,2], ind$coord[,3], meta_var$Type, 
                    meta_var$Strain)

colnames(ind_df) = c('Dim1', 'Dim2', 'Dim3', 'Type', 'Strain')

# get ellipses based on the correlation
getellipse = function(x, y, sc = 1) {
  as.data.frame(ellipse::ellipse(cor(x, y),
                                 scale = c(sd(x) * sc, sd(y) * sc),
                                 centre = c(mean(x), mean(y))))
}

# make a data frame from ellipses
ell = ind_df %>% group_by(Type, Strain) %>% do(getellipse(.$Dim1, .$Dim2, 1)) %>% data.frame

# plot!
ggplot(ind_df, aes(x = Dim1, y = Dim2, color = Strain, group = interaction(Type, Strain))) + 
  geom_point(size = 3, show.legend = NA, alpha = 0.5) + 
  geom_path(data = ell, aes(x = x, y = y, group = interaction(Type, Strain), linetype = Type), size = 1) +
  geom_polygon(data = ell, aes(x = x, y = y, group = interaction(Type, Strain), 
                               linetype = Type, fill = Strain), size = 1, alpha = 0.3) +
  xlab(paste("PC1 - ", round(res.pca$eig[1,2], 1), " % of variance", sep = "")) + 
  ylab(paste("PC2 - ", round(res.pca$eig[2,2], 1), " % of variance", sep = "")) +
  ggtitle(paste("PCA of strain:", paste(unique(ell$Strain), collapse = '_'))) + # paste inside a paste to collapse strain names
  theme(plot.title = element_text(hjust = 0.5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  theme_classic()


ggsave(file = here('summary','PCA_OP50_rcdA_PM1_2.pdf', sep = ''),
       width = 100, height = 80, units = 'mm', scale = 2, device = 'pdf')




# # # # # # # # # #
# Heatmaps ####
# # # # # # # # # #


hinfo <- data.b %>%
  group_by(SampleID, Strain, Type) %>%
  summarise %>%
  data.frame

rownames(hinfo) <- hinfo$SampleID
hinfo$SampleID <- NULL



cols <- list(Strain = c('BW' = "blue", 'TM' = "brown"),
             Type = c('Treatment' = 'red', 'Control' = 'black'))


oldinfo <- hinfo %>%
  select(-Strain)

# # Complete
# data.b %>%
#   filter(Plate %in% c('PM1', 'PM2A') & Strain == 'TM' & Metabolite != 'Negative Control') %>%
#   HMap('SampleID','MetaboliteU','logAUC', oldinfo, cols = cols) 
#   #Generate heatmap using ggplot. Again, nothing fancy. Code available in PFun R package



# dev.copy2pdf(device = cairo_pdf,
#              file = paste0(odir,'/Heatmap_BW_PM125.pdf'),
#              width = 5, height = 4, useDingbats = FALSE)



#### Heatmap ####

# metadata for columns in Heatmap
hinfo <- data.b %>%
  group_by(SampleID, Strain, Type) %>%
  summarise %>%
  data.frame

rownames(hinfo) <- hinfo$SampleID
hinfo$SampleID <- NULL

heatshape <- data.b %>%
  arrange(Plate) %>%
  select(SampleID, MetaboliteU, AUC) %>%
  spread(SampleID, AUC) %>%
  data.frame(check.names = FALSE)
rownames(heatshape) = heatshape[,1]
heatshape = heatshape[,-1] # delete names
colnames(heatshape) = unique(names(heatshape))


hinfo_rows <- data.b %>%
  group_by(MetaboliteU, Plate) %>%
  summarise %>%
  arrange((Plate)) %>%
  data.frame

rownames(hinfo_rows) <- hinfo_rows$MetaboliteU
hinfo_rows$MetaboliteU <- NULL

# ordering rows by plate 
heatshape = heatshape[rownames(hinfo_rows),]

# oldinfo <- hinfo %>%
#   select(-Strain)


cols <- list(Strain = c('OP50' = "blue", 'rcda' = "red"),
             Type = c('Treatment' = 'red', 'Control' = 'black'))

cols2 = list(Plate = c('PM1' = '#93FF21', 'PM2A' = '#E8A709', 'PM3B' = '#FF3417', 'PM4A' = '#9309E8', 'PM5' = '#0A8DFF'))


ha = HeatmapAnnotation(df = hinfo, col = cols)
ha2 = HeatmapAnnotation(df = hinfo_rows, col = cols2, which = "row")

# labels = c("BW", paste("BW", italic("gcvP"), sep = ""))

col_fun = colorRamp2(c(0, 6, 12), c("white", "orange", "red"))
col_fun(seq(-3, 3))

h1 = Heatmap(heatshape, 
             col = col_fun,
             #   col = colorRamp2(c(-2, -1, 0, 2), c("red", "orange","yellow", "green4")), # specifies the color range
             # column_title = 'Heatmap', # plot title
             # cell_fun = function(j, i, x, y, width, height, fill) {
             #   grid.text(sprintf("%.1f", heatshape[i, j]), x, y, gp = gpar(fontsize = 10))}, # plots numbers inside the cell
             column_title_gp = gpar(fontsize = 26, fontface = "bold"), # title options
             name = "AUC", # name of the legend
             clustering_distance_rows = "euclidean", # column clustering distance
             clustering_distance_columns = "euclidean", # row clustering distance
             clustering_method_rows = "ward.D2", # clustering method
             clustering_method_columns = "ward.D2", 
             # cluster_columns = FALSE, # this disable column order
             # cluster_rows = FALSE,  # this disable row order
             row_dend_reorder = FALSE, 
             top_annotation = ha, # top annotation with two classes 
             # top_annotation_height = unit(1, "cm"),
             row_names_side = "left", 
             show_column_names = T,
             column_names_side = "top",
             row_names_gp = gpar(fontsize = 14) # row text size, change this!
)

# creates a heatmap with row annotations
# HUGE and HEAVY heatmap
h1 + ha2

dev.copy2pdf(device = cairo_pdf,
             file = here('summary',"Heatmap_all.pdf"),
             width = 25, height = 60, useDingbats = FALSE)


## version with only PM1 and PM2


# version with ONLY PM1 and PM2
heatshape <- data.b %>%
  filter(Plate %in% c('PM1', 'PM2A')) %>%
  arrange(Plate) %>%
  select(SampleID, MetaboliteU, AUC) %>%
  spread(SampleID, AUC) %>%
  data.frame(check.names = FALSE)
rownames(heatshape) = heatshape[,1]
heatshape = heatshape[,-1] # delete names
colnames(heatshape) = unique(names(heatshape))

hinfo_rows <- data.b %>%
  filter(Plate %in% c('PM1', 'PM2A')) %>%
  group_by(MetaboliteU, Plate) %>%
  summarise %>%
  arrange((Plate)) %>%
  data.frame

rownames(hinfo_rows) <- hinfo_rows$MetaboliteU
hinfo_rows$MetaboliteU <- NULL

# ordering rows by plate 
heatshape = heatshape[rownames(hinfo_rows),]

# oldinfo <- hinfo %>%
#   select(-Strain)


cols <- list(Strain = c('OP50' = "blue", 'rcda' = "red"),
             Type = c('Treatment' = 'red', 'Control' = 'black'))

cols2 = list(Plate = c('PM1' = '#93FF21', 'PM2A' = '#E8A709'))


ha = HeatmapAnnotation(df = hinfo, col = cols)
ha2 = HeatmapAnnotation(df = hinfo_rows, col = cols2, which = "row")

# labels = c("BW", paste("BW", italic("gcvP"), sep = ""))

col_fun = colorRamp2(c(0, 6, 12), c("white", "orange", "red"))
col_fun(seq(-3, 3))

h1 = Heatmap(heatshape, 
             col = col_fun,
             #   col = colorRamp2(c(-2, -1, 0, 2), c("red", "orange","yellow", "green4")), # specifies the color range
             # column_title = 'Heatmap', # plot title
             # cell_fun = function(j, i, x, y, width, height, fill) {
             #   grid.text(sprintf("%.1f", heatshape[i, j]), x, y, gp = gpar(fontsize = 10))}, # plots numbers inside the cell
             column_title_gp = gpar(fontsize = 26, fontface = "bold"), # title options
             name = "AUC", # name of the legend
             clustering_distance_rows = "euclidean", # column clustering distance
             clustering_distance_columns = "euclidean", # row clustering distance
             clustering_method_rows = "ward.D2", # clustering method
             clustering_method_columns = "ward.D2", 
             # cluster_columns = FALSE, # this disable column order
             # cluster_rows = FALSE,  # this disable row order
             row_dend_reorder = FALSE, 
             top_annotation = ha, # top annotation with two classes 
             # top_annotation_height = unit(1, "cm"),
             row_names_side = "left", 
             show_column_names = T,
             column_names_side = "top",
             row_names_gp = gpar(fontsize = 14) # row text size, change this!
)

# creates a heatmap with row annotations
# HUGE and HEAVY heatmap
h1 + ha2

dev.copy2pdf(device = cairo_pdf,
             file = here('summary',"Heatmap_PM1_2.pdf"),
             width = 15, height = 25, useDingbats = FALSE)




# # # # # # # # # # #
# scatter plots #####
# # # # # # # # # # #


# op50

cosa = data.b %>% filter(Strain == 'OP50') %>%
  filter(!Metabolite %in% c('Negative Control')) %>%
  select(MetaboliteU, Replicate, Type, AUC) %>%
  pivot_wider(names_from = Type, Replicate, values_from = AUC)
  



# linear modeling
  
contrasts <- read.contrasts('!Contrasts.xlsx') # This table describes comparisons made in data

# loads the metadata table
contrasts.table <- contrasts$Contrasts.table
# loads the contrasts matrix (1s and 0s)
contr.matrix <- contrasts$Contrasts.matrix

# shortens the metadata data frame
contr.desc <- contrasts.table %>%
  select(Description:Strain)



contr.matrix

# Initialise adjustments
group <- c('All','PM5','PM4A','PM3B','PM2A','PM1')
strain <- c('OP50','rcda')


adjustments <- expand.grid('Group' = group, 'Strain' = strain) %>%
  mutate(a = -1, b = 0,
         Contrast = paste0(Strain, '_Metf_', Group, 'n')) %>%
  select(Contrast, Group:b) 



# transform the contr.matrix into a real matrix (not data frame)
contr.matrix <- contr.matrix %>%
  as.matrix()


# this piece of code performs a lot of different things, be careful

allresults <- data.b %>%
  #filter(Strain == 'BW') %>%
  filter(!Metabolite %in% c('Negative Control','Positive Control')) %>%
  # filter(! (Plate == 'PM3B' & SampleID == 'BW_C_1') ) %>%
  # filter(! (Plate == 'PM4A' & SampleID == 'TM_C_3') ) %>%
  group_by(Plate, Well, Index, Metabolite, MetaboliteU, EcoCycID, KEGG_ID) %>%
  # Another creation of mine. Nothing fancy, just a wrapper for the use of contrasts in LM. 
  # But integrates nicely with tidyverse workflow. Code in PFun
  do(hypothesise(.,"AUC~0+Sample", contr.matrix)) %>% 
  group_by(Plate, Well, Metabolite, MetaboliteU, EcoCycID, KEGG_ID) %>%
  getresults(contr.desc) # Calculate some additional parameters. Code in PFun

#get results in different shapes
results <- allresults$results
results.cast <- allresults$cast
results.castfull <- allresults$castfull

results$Contrast %>% unique %>% as.character


results %>% filter(Contrast_type == 'Strain')

# Save statistical analysis results
write.csv(results,here('summary','Ecoli_results.csv'),row.names = FALSE)
write.csv(results.cast,here('summary','Ecoli_results_sidebyside.csv', sep = ''), row.names = FALSE)
write.csv(results.castfull,here('summary','Ecoli_results_sidebyside_full.csv',sep=''), row.names = FALSE)


### test data
met = 'D-Mannose'
data.b %>% 
  filter(MetaboliteU == met) %>%
  ggplot(aes(x = Type, y = AUC, fill = Type)) +
  geom_boxplot() +
  facet_wrap(~Strain)
results %>% filter(MetaboliteU == met)





# # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Enrichment analysis of metabolites and pathways #####
# # # # # # # # # # # # # # # # # # # # # # # # # # # #


# load other helper files for KEGG and EcoCyc enrichment
# KEGG mappings
kegg.mappings = read_csv(here('Bacteria data',"All_KEGG_mappings_Complete.csv")) %>%
  separate_rows(all.mapped) %>%
  filter(!is.na(all.mapped)) %>%
  group_by(all.mapped) %>%
  summarise(Pathway_IDs = paste(unique(PathwayID), collapse = ';'),
            Pathways = paste(unique(Description), collapse = ';'))

#EcoCyc mappings
EC_mappings = read_csv(here('Bacteria data','EcoCyc_Class_mappings.csv'))

# filter some results that are not useful now
res = results %>% filter(Contrast_type == 'Treatment')

# some strange thing
ecomulti = multiplex(res, c("Plate","Well","Index","MetaboliteU","EcoCycID","KEGG_ID"),3)

# 
all.results.KEGG = res %>%
  left_join(kegg.mappings,by = c('KEGG_ID'='all.mapped')) %>%
  left_join(EC_mappings) 
# %>%
# select(Organism,Organism_short,OMC:KEGG_ID,Pathway_IDs,Pathways,EcoCyc_Instances,EcoCyc_Classes,everything())



EcoCyc.enrichment = all.results.KEGG %>%
  left_join(EC_mappings) %>%
  left_join(info) %>%
  filter(!is.na(FDR) & !is.na(EcoCyc_Classes)) %>%
  enrichment(
    featureid = 'EcoCyc_Instances',
    groups = c('Contrast','Strain', 'Class')) 




EcoCyc.enrichment %>%
  filter(Type!="All" & OMC %in% c("Ec_G_T-C","Ce_F_T-C") & !Class %in% EChm$Class)%>%
  select(-c(NoInstances:Comparison),-c(Organism_short,Measure,Contrast,OMC) ) %>%
  write_csv(paste0(odir,'/EcoCyc_enrichment.csv'))



### ok, summary until this point of the code. I got the hypergeometric test to work with our 
### samples, which is good. I would need to make it a function. But, it seems that the database
### I was using is not good, it does not contain all the names Im interested, so I need to make
### a good one from another file from Pov's folders

# read file
EC_classes = read_csv(here('Bacteria data',"All_results_side_by_side_withKEGGEcoCycClass.csv")) %>%
  select(Plate:EcoCyc_Classes) 


# separate rows with strsplit 
# EC_classes %>% 
#     mutate(EcoCyc_Classes = strsplit(as.character(EcoCyc_Classes), ';')) %>% 
#     unnest(EcoCyc_Classes)

# v2, with separate_rows
EC_classes = EC_classes %>% 
  separate_rows(EcoCyc_Classes, sep = ';')

# test if all metabolites are included in the list
met %in% EC_classes$EcoCycID



EC_path = read_csv(here('Bacteria data',"All_results_side_by_side_withKEGGEcoCycClass.csv")) %>%
  select(Plate:EcoCyc_Classes) %>%
  separate_rows(Pathways, sep = ';')


###
# let's do it with every set

res.OP50 = res %>% filter(Strain == 'OP50', Contrast == 'OP50_metf')
res.rcda = res %>% filter(Strain == 'rcda', Contrast == 'rcda_metf')
res.inter = results %>% filter(Contrast_type == 'Interaction')


# total metab
met = res.OP50 %>% filter(Metabolite != 'Negative Control', !Plate == 'PM5') %>% select(EcoCycID) %>% t %>% as.vector

# significative metabolites 
sig.met.OP50.up =   res.OP50 %>% filter(Metabolite != 'Negative Control', !Plate == 'PM5', FDR < 0.05, logFC > 0) %>% select(EcoCycID) %>% t %>% as.vector
sig.met.OP50.down = res.OP50 %>% filter(Metabolite != 'Negative Control', !Plate == 'PM5', FDR < 0.05, logFC < 0) %>% select(EcoCycID) %>% t %>% as.vector

sig.met.rcda.up =   res.rcda %>% filter(Metabolite != 'Negative Control', !Plate == 'PM5', FDR < 0.05, logFC > 0) %>% select(EcoCycID) %>% t %>% as.vector
sig.met.rcda.down = res.rcda %>% filter(Metabolite != 'Negative Control', !Plate == 'PM5', FDR < 0.05, logFC < 0) %>% select(EcoCycID) %>% t %>% as.vector

sig.met.inter.up =   res.inter %>% filter(Metabolite != 'Negative Control', !Plate == 'PM5', FDR < 0.05, logFC > 0) %>% select(EcoCycID) %>% t %>% as.vector
sig.met.inter.down = res.inter %>% filter(Metabolite != 'Negative Control', !Plate == 'PM5', FDR < 0.05, logFC < 0) %>% select(EcoCycID) %>% t %>% as.vector


N = length(met)

### calculate enrichment values
### OP50
# up 
classes = unique(EC_classes$EcoCyc_Classes)
enrich.BW.up = c()
for (class in classes){
  class.met = EC_classes %>% filter(EcoCyc_Classes == class) %>% select(EcoCycID) %>% t %>% as.vector
  m = length(class.met)
  n = N - m
  k = length(sig.met.OP50.up)
  x = length(class.met[class.met %in% sig.met.OP50.up])
  fit = phyper(q = x-1, m = m, n = n, k = k, lower.tail = FALSE)
  enrich.BW.up = c(enrich.BW.up, fit)
}

# enrich.BW.up = p.adjust(enrich.BW.up, method = 'fdr')
names(enrich.BW.up) = classes
enrich.BW.up = enrich.BW.up[enrich.BW.up < 0.05]

# down 
classes = unique(EC_classes$EcoCyc_Classes)
enrich.BW.down = c()
for (class in classes){
  class.met = EC_classes %>% filter(EcoCyc_Classes == class) %>% select(EcoCycID) %>% t %>% as.vector
  m = length(class.met)
  n = N - m
  k = length(sig.met.OP50.down)
  x = length(class.met[class.met %in% sig.met.OP50.down])
  fit = phyper(q = x-1, m = m, n = n, k = k, lower.tail = FALSE)
  enrich.BW.down = c(enrich.BW.down, fit)
}

# enrich.BW.down = p.adjust(enrich.BW.down, method = 'fdr')
names(enrich.BW.down) = classes
enrich.BW.down = enrich.BW.down[enrich.BW.down < 0.05]




### rcda
# up

classes = unique(EC_classes$EcoCyc_Classes)
enrich.pyrE.up = c()
for (class in classes){
  class.met = EC_classes %>% filter(EcoCyc_Classes == class) %>% select(EcoCycID) %>% t %>% as.vector
  m = length(class.met)
  n = N - m
  k = length(sig.met.rcda.up)
  x = length(class.met[class.met %in% sig.met.rcda.up])
  fit = phyper(q = x-1, m = m, n = n, k = k, lower.tail = FALSE)
  enrich.pyrE.up = c(enrich.pyrE.up, fit)
}

# enrich.pyrE.up = p.adjust(enrich.pyrE.up, method = 'fdr')
names(enrich.pyrE.up) = classes
enrich.pyrE.up = enrich.pyrE.up[enrich.pyrE.up < 0.05]

# down
classes = unique(EC_classes$EcoCyc_Classes)
enrich.pyrE.down = c()
for (class in classes){
  class.met = EC_classes %>% filter(EcoCyc_Classes == class) %>% select(EcoCycID) %>% t %>% as.vector
  m = length(class.met)
  n = N - m
  k = length(sig.met.rcda.down)
  x = length(class.met[class.met %in% sig.met.rcda.down])
  fit = phyper(q = x-1, m = m, n = n, k = k, lower.tail = FALSE)
  enrich.pyrE.down = c(enrich.pyrE.down, fit)
}

# enrich.pyrE.down = p.adjust(enrich.pyrE.down, method = 'fdr')
names(enrich.pyrE.down) = classes
enrich.pyrE.down = enrich.pyrE.down[enrich.pyrE.down < 0.05]




### interaction
# up

classes = unique(EC_classes$EcoCyc_Classes)
enrich.inter.up = c()
for (class in classes){
  class.met = EC_classes %>% filter(EcoCyc_Classes == class) %>% select(EcoCycID) %>% t %>% as.vector
  m = length(class.met)
  n = N - m
  k = length(sig.met.inter.up)
  x = length(class.met[class.met %in% sig.met.inter.up])
  fit = phyper(q = x-1, m = m, n = n, k = k, lower.tail = FALSE)
  enrich.inter.up = c(enrich.inter.up, fit)
}

# enrich.inter.up = p.adjust(enrich.inter.up, method = 'fdr')
names(enrich.inter.up) = classes
enrich.inter.up = enrich.inter.up[enrich.inter.up < 0.05]


# down
classes = unique(EC_classes$EcoCyc_Classes)
enrich.inter.down = c()
for (class in classes){
  class.met = EC_classes %>% filter(EcoCyc_Classes == class) %>% select(EcoCycID) %>% t %>% as.vector
  m = length(class.met)
  n = N - m
  k = length(sig.met.inter.down)
  x = length(class.met[class.met %in% sig.met.inter.down])
  fit = phyper(q = x-1, m = m, n = n, k = k, lower.tail = FALSE)
  enrich.inter.down = c(enrich.inter.down, fit)
}

# enrich.inter.down = p.adjust(enrich.inter.down, method = 'fdr')
names(enrich.inter.down) = classes
enrich.inter.down = enrich.inter.down[enrich.inter.down < 0.05]






# let's workout the results from each enrichment

enrich.BW.up      = data.frame(enrich.BW.up     ) %>% mutate(Class = rownames(.), Direction =   'up', Strain =   'OP50');        
enrich.BW.down    = data.frame(enrich.BW.down   ) %>% mutate(Class = rownames(.), Direction = 'down', Strain =   'OP50');       
enrich.pyrE.up    = data.frame(enrich.pyrE.up   ) %>% mutate(Class = rownames(.), Direction =   'up', Strain = 'rcda');       
enrich.pyrE.down  = data.frame(enrich.pyrE.down ) %>% mutate(Class = rownames(.), Direction = 'down', Strain = 'rcda');       
enrich.inter.up    = data.frame(enrich.inter.up   ) %>% mutate(Class = rownames(.), Direction =   'up', Strain = 'Interaction');       
enrich.inter.down  = data.frame(enrich.inter.down ) %>% mutate(Class = rownames(.), Direction = 'down', Strain = 'Interaction');       



names(enrich.BW.up)[1] = 'p.value'
names(enrich.BW.down)[1] = 'p.value'
names(enrich.pyrE.up)[1] = 'p.value'
names(enrich.pyrE.down)[1] = 'p.value'
names(enrich.inter.up)[1] = 'p.value'
names(enrich.inter.down)[1] = 'p.value'



bac.enrich = rbind(enrich.BW.up, enrich.BW.down, enrich.pyrE.up, enrich.pyrE.down, enrich.inter.up, enrich.inter.down)

# bac.enrich %>%
#     ggplot(aes(x = Direction, y = Class)) +
#     geom_tile(aes(fill = p.value)) +
#     facet_wrap(~Strain)

# lets build a new dataframe that has all the info we need for plotting
classes = sort(unique(bac.enrich$Class))
direct = c('up', 'down')

df = expand.grid(Strain = c('OP50', 'rcda', 'Interaction'),
                 Class = classes,
                 Direction = c('up', 'down'))

df = left_join(df, bac.enrich) %>%
  mutate(p.value = replace_na(p.value, 1))

# enrichment procedure
enrbrks = c(0, -log(0.05, 10), 2, 3, 4, 100)
enrlbls = c('N.S.','<0.05','<0.01','<0.001','<0.0001')
enrcols = colorRampPalette(c("gray90", "steelblue1", "blue4"))(n = 6)

p.theme = theme(axis.ticks = element_blank(), panel.border = element_blank(), 
                panel.background = element_blank(), panel.grid.minor = element_blank(), 
                panel.grid.major = element_blank(), axis.line = element_line(colour = NA), 
                axis.line.x = element_line(colour = NA), axis.line.y = element_line(colour = NA), 
                strip.text = element_text(colour = "black", face = "bold", 
                                          size = 10), axis.text.x = element_text(face = "bold", 
                                                                                 colour = "black", size = 10, angle = 90, hjust = 1))


# plot enrichment p-values
df %>% 
  mutate(p.value = p.value + 0.00000001,
         logFDR = ifelse(-log10(p.value) < 0, 0, -log10(p.value)),
         logFDRbin = cut(logFDR, breaks = enrbrks, labels = enrlbls, right = FALSE),
         Class = factor(Class, levels = sort(classes, decreasing = T)),
         Direction = factor(Direction, levels = sort(direct, decreasing = T))) %>%
  ggplot(aes(x = Direction, y = Class)) +
  geom_tile(aes(fill = logFDRbin)) +
  scale_fill_manual(values = enrcols) + 
  facet_wrap(~Strain) +
  # labs(fill = 'FDR') + 
  p.theme


dev.copy2pdf(device = cairo_pdf,
             file =here('Summary', 'Enrich_metab_class_bacteria.pdf'),
             width = 6, height = 8, useDingbats = FALSE)







# growth data -------------------------------------------------------------

time.data = read_csv('original_data/PM1to5/Output/Timeseries.csv', quote = "\"") %>%
  filter(Data == '750nm_f') %>%
  gather(Time_s, OD, matches('\\d')) %>%
  drop_na(Time_s) %>% 
  mutate(Strain = as.character(Strain), # Change strain namings
         # ReplicateB = paste0('B', as.character(Replicate)), #Generate replicate ID which indicate that it's data for bacteria
         Type = ifelse(Type == 'Control','C','T'),
         Sample = paste(Strain, Type, sep = '_'),
         Type = factor(Type,
                       levels = c('C', 'T'),
                       labels = c('Control', 'Treatment')),
         Time_s = as.numeric(Time_s),
         Time_h = Time_s/3600,
         Row = str_match_all(Well,'[:digit:]{1,}'), #Get plate row names from well name. 
         Col = str_match_all(Well,'[:alpha:]{1,}'), #Get plate column names from well name
         Row = factor(Row, levels = 1:12), #Make them categorical variable with set order them
         Col = factor(Col, levels = LETTERS[1:8])) %>%
  select(c(-File, -Data, -Reader)) %>%
  # rename(Strain = Str, Replicate = Replicate_y) %>%
  mutate_at(c('Well', 'Strain', 'Metformin_mM'), as.factor)




# Generate summary statistics for each group
bac.sum = data.b %>%
  group_by(Strain, Plate, Replicate, Group) %>%
  gather(Measure, Value, AUC_raw, AUC) %>%
  group_by(Measure, Strain, Type, Plate, Well, Index, Metabolite, MetaboliteU) %>% #Work on subsets based on selected grouping variables
  summarise(Mean = mean(Value, na.rm = TRUE), # Do selected summary over group items - replicates, ignore missing values
            SD = sd(Value, na.rm = TRUE),
            SE = SD/sqrt(n())) %>% # standard error of the mean
  ungroup %>%
  mutate(PE = Mean+SE,
         NE = Mean-SE)


tsum = time.data %>%
  group_by(Plate, Metformin_mM, Strain, Type, Well, Index, Metabolite, MetaboliteU, Time_h) %>%
  summarise(Mean = mean(OD), SD = sd(OD), SE = SD/sqrt(length(OD))) %>%
  ungroup 


tsum = tsum %>% filter(Metformin_mM == 0)


## plotting all temporal series in a grid
lvls = naturalsort::naturalsort(unique(tsum$Well))

tsum %>%
  filter(Well == 'A1') %>%
  ggplot(aes(x = Time_h, y = Mean, fill = Strain, color = Strain)) +
  geom_ribbon(aes(ymin = Mean - SD, ymax = Mean + SD), color = NA, alpha = 0.4) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, 24, by = 6)) +
  ylab("OD") +
  xlab("Time, h") +
  facet_wrap(vars(Plate)) +
  scale_colour_manual(values = c('#EDBD24', '#2E49EB')) +
  scale_fill_manual(values = c('#EDBD24', '#2E49EB')) +
  # theme(panel.grid.major = element_blank(),
  #       panel.grid.minor = element_blank(),
  #       panel.background = element_rect(fill = "white", colour = "grey50")) 
  cowplot::theme_cowplot(15)



ggsave(file = paste(odir,'/Bacterial_growth.pdf',sep = ''),
       width = 80, height = 80, units = 'mm', scale = 2, device = 'pdf')





dir.create(here('summary/individual_plots'))


metabs = tsum %>% 
  unite(metab_plate, c(MetaboliteU, Plate), sep = ' - ') %>%
  distinct(metab_plate) %>% 
  pull(metab_plate)


  
tsum = tsum %>% 
  unite(metab_plate, c(MetaboliteU, Plate), sep = ' - ', remove = F)

tsum2 = tsum %>% 
  mutate(Strain = case_when(Strain == 'OP50' ~ "OP50 WT",
                            Strain == 'rcda' ~ "OP50 &Delta;<i>rcdA</i>"),
         Strain = factor(Strain, levels = c("OP50 WT", "OP50 &Delta;<i>rcdA</i>" )))


tsum2 %>% 
  mutate(metab_plate = case_when(str_detect(metab_plate, '_Nutritional supplement')))




for (met in metabs){

  tsum2 %>%
    filter(metab_plate == met) %>%
    ggplot(aes(x = Time_h, y = Mean, fill = Strain, color = Strain)) +
    geom_ribbon(aes(ymin = Mean - SD, ymax = Mean + SD), color = NA, alpha = 0.4) +
    geom_line() +
    scale_x_continuous(breaks = seq(0, 24, by = 6)) +
    ylab("OD") +
    xlab("Time, h") +
    facet_wrap(vars(metab_plate)) +
    scale_colour_manual(values = c('#2E49EB', '#EDBD24')) +
    scale_fill_manual(values = c('#2E49EB', '#EDBD24')) +
    cowplot::theme_cowplot(15) +
    theme(
      legend.text = element_markdown(family = 'Arial')
    )
  
  ggsave(file = here('summary/individual_plots', glue::glue('{met}_growth.pdf')),
         width = 8, height = 8, device = cairo_pdf)

}



plates = tsum %>% 
  distinct(Plate) %>% 
  pull(Plate)


# dir.create(here('summary/individual_plates'))



for (plate in plates){
  
  tsum2 %>%
    mutate(MetaboliteU = str_wrap(MetaboliteU, width = 15)) %>% 
    mutate(MetaboliteU = str_replace_all(MetaboliteU, '_',' ')) %>% 
    filter(Plate == plate) %>%
    ggplot(aes(x = Time_h, y = Mean, fill = Strain, color = Strain)) +
    geom_ribbon(aes(ymin = Mean - SD, ymax = Mean + SD), color = NA, alpha = 0.4) +
    geom_line() +
    scale_x_continuous(breaks = seq(0, 24, by = 6)) +
    ylab("OD") +
    xlab("Time, h") +
    facet_wrap(vars(MetaboliteU), nrow = 12, ncol = 12) +
    scale_colour_manual(values = c('#2E49EB', '#EDBD24')) +
    scale_fill_manual(values = c('#2E49EB', '#EDBD24')) +
    cowplot::theme_cowplot(15) +
    theme(
      legend.text = element_markdown()
    )
  
  
  ggsave(file = here('summary/individual_plates', glue::glue('{plate}_growth.pdf')),
         width = 22, height = 21, device = cairo_pdf)
  
}




# enrichment_2 ------------------------------------------------------------

# read the data table with gene info

ecocyc = read_csv("EcoCyc_genes_pathways.csv")

##### Hypergeometric function ########


# hypergeometric test function

enrich = function(gene, db){
  # initiate variables
  pval = c()
  m_total = c()
  x_total = c()
  k_total = c()
  gene_in_cat = c()
  db = as.data.frame(db)
  cats = unique(db[,2])
  
  for (cat in cats){
    subcat = db[db[,2] == cat,]
    N = (db %>% distinct(.[,1]) %>% count())$n
    m = dim(subcat)[1]
    n = N - m
    x = sum(gene %in% subcat[,1])
    k = sum(gene %in% db[,1]) # genes with at least 1 annotation!
    p = phyper(q=x-1, m=m, n=n, k=k, lower.tail=FALSE)
    
    # save variables
    m_total = c(m_total, m)
    x_total = c(x_total, x)
    k_total = c(k_total, k)
    gene_in_cat = c(gene_in_cat)
    pval = c(pval, p)
  }
  
  # build the table
  table = tibble(categories = cats, N = N, elm_in_cat = m_total, gene_in_cat = x_total, k_tot = k, pval = pval) %>% 
    mutate(
      p.stars = gtools::stars.pval(pval),
      fdr = p.adjust(pval, method = 'fdr'),
      fdr.stars = gtools::stars.pval(fdr)
    ) %>% 
    arrange(pval)
  
  return(table)
  
}



results %>% 
  filter(Description == 'rcdA difference from OP50 in control') %>% 
  filter(FDR < 0.05, 
         logFC < 0) %>% 
  pull(EcoCycID)


# calculate enrichment for the different sets
genes = group_1$Genes
g1.enrich = enrich(genes, db = ecocyc) %>% mutate(direction = 'group_1')











